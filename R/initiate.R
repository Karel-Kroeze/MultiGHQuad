#' Q-dimensional grid of quadrature points.
#' 
#' Creates a flattened, rotated grid that incorporates correlation through an eigenvalue decomposition of the covariance matrix.
#'
#' Creates a Q-dimensional grid by calling \code{\link{expand.grid}} on Q vectors of unidimensional quadrature points.
#' The grid is corrected for covariation by eigenvalue decomposition;
#' \deqn{\Sigma = S \times \Lambda \times S^T}{ Sigma = S \%*\% Lambda \%*\% t(S) }
#' Take \code{A} to be;
#' \deqn{A = S \times \sqrt(\Lambda)}{A = S \%*\% \sqrt(\Lambda)}
#' And left multiply the quadrature points \code{z} by \code{A} to obtain correlated quadrature points \code{r};
#' \deqn{r = A \times z}{r = A \%*\% z}
#' 
#' @param Q Number of dimensions. Defaults to 2. Only required when \code{mu} and \code{Sigma} are not provided.
#' @param mu Mean vector, defaults to rep(0,Q), the zero vector of length Q. CURRENTLY NOT IMPLEMENTED.
#' @param Sigma Covariance matrix, defaults to diag(Q), the identity matrix of rank Q.
#' @param ip Number of quadrature points \emph{per dimension}. Defaults to 6. Note that the total number of quadrature points is \code{ip^Q}.
#' @return A list with a matrix \code{X} of \code{ip^Q} by \code{Q} quadrature points and a vector \code{W} of length \code{ip^Q} associated weights.
#' @seealso \code{\link[fastGHQuad]{gaussHermiteData}}, used to create unidimensional quadrature points, and \code{\link{MGHQuadEval}} for evaluating the integral.
#' @export
#' @examples
#' # generate some noise with a given covariance matrix
#' \dontrun{
#' require(mvtnorm)
#' sigma <- matrix(c(1,.8,.8,1),ncol=2,byrow=T)
#' noise <- rmvnorm(1e4,mean=c(0,0),sigma=sigma)
#' # plot noise
#' plot(noise,col='red',pch='.')
#' 
#' # generate quadrature points
#' quadPoints <- MGHQuadPoints(mu=c(0,0),Sigma=sigma,ip=10)
#' 
#' # plot quad points
#' points(quadPoints$X,pch=16)
#' 
#' # plot quad points with weights
#' plot(noise,col='red',pch='.')
#' points(quadPoints$X,col=grey(1-quadPoints$W/max(quadPoints$W)),pch=16)
#' }

init.quad <- function(Q=2,mu=rep(0,Q),Sigma=diag(Q),ip=6){
  # TODO: account for mu != 0.
  # get quadrature points, apply normal pdf
  x <- fastGHQuad::gaussHermiteData(ip)
  w <- x$w / sqrt(pi)
  x <- x$x * sqrt(2)
  
  # (if anyone knows an easy way to assign a single vector x times to x list elements, please tell me. )
  X <- as.matrix(expand.grid(lapply(apply(replicate(Q,x),2,list),unlist)))
  
  # compute lambda (eigen decomposition covar matrix)
  lambda <- with(eigen(Sigma), vectors %*% diag(sqrt(values)))
  
  # apply mv normal pdf error function 
  # account for correlation
  X <- t(lambda %*% t(X))

  # calculate weights
  # same as above, roundabout way to get the combn weights for each combination of quad points
  g <- as.matrix(expand.grid(lapply(apply(replicate(Q,w),2,list),unlist)))
  # combined weight is the product of the individual weights
  W <- apply(g,1,prod)
  
  return(invisible(list(X=X,W=W)))
}