% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/initiate.R
\name{init.quad}
\alias{init.quad}
\title{Q-dimensional grid of quadrature points.}
\usage{
init.quad(Q = 2, prior = list(mu = rep(0, Q), Sigma = diag(Q)),
  adapt = NULL, ip = 6, prune = TRUE)
}
\arguments{
\item{Q}{Number of dimensions. Defaults to 2. Only required when \code{mu} and \code{Sigma} are not provided.}

\item{prior}{List of prior mean \code{mu}, = \code{vector}, and covariance matrix \code{Sigma} = \code{matrix}, defaults to zero vector and identity matrix respectively.}

\item{adapt}{List of adaptive mean \code{mu}, = \code{vector}, and covariance matrix \code{Sigma} = \code{matrix}, if \code{NULL} no adaptation is used. Defaults to NULL.}

\item{ip}{Number of quadrature points \emph{per dimension}. Defaults to 6. Note that the total number of quadrature points is \code{ip^Q}.}

\item{prune}{Logical, should quadrature points with a very low weight be removed? Defaults to true. See details.}
}
\value{
A list with a matrix \code{X} of \code{ip^Q} by \code{Q} quadrature points and a vector \code{W} of length \code{ip^Q} associated weights.
}
\description{
Creates a flattened, rotated grid that incorporates correlation through an eigenvalue decomposition of the covariance matrix.
}
\details{
Creates a Q-dimensional grid by calling \code{\link{expand.grid}} on Q vectors of unidimensional quadrature points.
The grid is corrected for covariation by eigenvalue decomposition;
\deqn{\Sigma = S \times \Lambda \times S^T}{ Sigma = S \%*\% Lambda \%*\% t(S) }
Take \code{A} to be;
\deqn{A = S \times \sqrt(\Lambda)}{A = S \%*\% \sqrt(\Lambda)}
And left multiply the quadrature points \code{z} by \code{A} to obtain correlated quadrature points \code{r};
\deqn{r = A \times z}{r = A \%*\% z}

Adaptive.

Pruning.
}
\examples{
# generate some noise with a given covariance matrix
\dontrun{
require(mvtnorm)
sigma <- matrix(c(1,.8,.8,1),ncol=2,byrow=T)
noise <- rmvnorm(1e4,mean=c(0,0),sigma=sigma)
# plot noise
plot(noise,col='red',pch='.')

# generate quadrature points
quadPoints <- init.quad(prior = list(mu=c(0,0),Sigma=sigma),ip=10)

# plot quad points
points(quadPoints$X,pch=16)

# plot quad points with (log) weights
plot(noise,col='red',pch='.')
points(quadPoints$X,col=grey(1-quadPoints$W/max(quadPoints$W)),pch=16)
}
}
\seealso{
\code{\link[fastGHQuad]{gaussHermiteData}}, used to create unidimensional quadrature points, and \code{\link{eval.quad}} for evaluating the integral.
}

